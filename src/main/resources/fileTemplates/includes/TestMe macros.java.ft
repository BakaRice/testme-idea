################## Global vars ###############
#set($trackedImports={})## map (name -> canonicalName) of types already imported
#foreach($typeName in $TESTED_CLASS_TYPES_IN_DEFAULT_PACKAGE)#set( $devNull= $trackedImports.put($typeName,""))#end
#set($trackedTestMethodsCount={})
#set($replacementTypes = {
    "java.util.Collection": "java.util.ArrayList",
    "java.util.Deque": "java.util.LinkedList",
    "java.util.Deque": "java.util.LinkedList",
    "java.util.List": "java.util.ArrayList",
    "java.util.Map": "java.util.HashMap",
    "java.util.NavigableMap": "java.util.TreeMap",
    "java.util.NavigableSet": "java.util.TreeSet",
    "java.util.Queue": "java.util.LinkedList",
    "java.util.RandomAccess": "java.util.Vector",
    "java.util.Set": "java.util.HashSet",
    "java.util.SortedSet": "java.util.TreeSet"
})
#set($defaultTypeValues = {
    "byte": "(byte) 0",
    "short": "(short) 0",
    "int": "0",
    "long": "0L",
    "float": "0f",
    "double": "0d",
    "char": "'a'",
    "boolean": "true",
    "java.lang.Byte": "Byte.valueOf(""00110"")",
    "java.lang.Short": "Short.valueOf((short)0)",
    "java.lang.Integer": "Integer.valueOf(0)",
    "java.lang.Integer": "Integer.valueOf(0)",
    "java.lang.Long": "Long.valueOf(1)",
    "java.lang.Float": "Float.valueOf(1.1f)",
    "java.lang.Double": "Double.valueOf(0)",
    "java.lang.Character": "Character.valueOf('a')",
    "java.lang.Boolean": "Boolean.TRUE",
    "java.math.BigDecimal": "new java.math.BigDecimal(0)",
    "java.util.Date": "new java.util.GregorianCalendar($YEAR, java.util.Calendar.$MONTH_NAME_EN.toUpperCase(), $DAY, $HOUR, $MINUTE).getTime()"
})
##
##
################## Macros #####################
#macro( renderJavaCallParams $params $recursionDepth)
#set($recursionDepth=$recursionDepth+1)
#foreach($param in $params)#*
    *##if($foreach.count>1), #end#*
    *##renderJavaCallParam($param.type,$param.name, $recursionDepth)##
#end
#end
##
#macro( renderJavaCallParam $type $strValue $recursionDepth)
#if($type.array)new #resolveTypeName($type, {})[]{#end#renderJavaParam($type,$strValue $recursionDepth)#if($type.array)}#end
#end
##
#macro( renderJavaParam $type $strValue $recursionDepth)
#if($defaultTypeValues.get($type.canonicalName))$defaultTypeValues.get($type.canonicalName)##
#elseif($type.canonicalName == "java.lang.String")"${strValue}"##
#elseif($type.enumValues.size()>0)#resolveTypeName($type, {}).${type.enumValues[0]}##
#else##
#set($typeName="#resolveTypeName($type $replacementTypes)")##
new $typeName(#if($recursionDepth<=$MAX_RECURSION_DEPTH)#renderCtorParams($typeName,$type,$recursionDepth)#end)#end
#end
##
#macro( renderCtorParams $typeName $type $recursionDepth)
#if(($typeName==$type.name || $typeName==$type.canonicalName) && $type.constructors.size()>0)##
#renderJavaCallParams($type.constructors.get(0).methodParams, $recursionDepth)
#end
#end
##
#macro( resolveTypeName $type $replacementTypesMap)
#set($name=$type.name)##
#set($canonicalName=$type.canonicalName)##
#set($sanitizedCanonicalName=$ClassUtils.stripGenerics($canonicalName))##
#set($sanitizedName=$ClassUtils.stripGenerics($name))##
#set($packageName=$type.packageName)##
#if($replacementTypesMap.get( $sanitizedCanonicalName))#*
    *##set($sanitizedCanonicalName=$replacementTypesMap.get($sanitizedCanonicalName))#*
    *##set($sanitizedName = $ClassUtils.extractClassName($sanitizedCanonicalName))#*
    *##set($name = $ClassUtils.replaceType($name,$sanitizedName))#*
    *##set($canonicalName = $ClassUtils.replaceType($canonicalName,$sanitizedCanonicalName))##
#end
#if($packageName.length()>0 && $packageName != "java.lang" && $packageName != $package && !($trackedImports.get($sanitizedName)==$sanitizedCanonicalName))$canonicalName##
#{else}$name#end
#end
##
#macro( renderJavaTestClassImports $fields $methods $package)
#foreach($field in $fields)
#renderImport($field.type,$package,{})
#end
#foreach($method in $methods)#*
    *##if($method.isTestable())#*
        *##if($method.returnType)#*
            *##renderImport($method.returnType,$package,{})#*
            *##renderImport($method.returnType,$package, $replacementTypes)#end#*
        *##foreach($param in $method.methodParams)#*
            *##renderImport($param.type,$package, $replacementTypes)#end#*
    *##end
#end
#end
##
#macro(renderImport $wrapperType $package $replacementTypesMap)
#foreach($type in $wrapperType.composedTypes)#*
    *##set($name=$type.name)#*
    *##set($canonicalName=$type.canonicalName)#*
    *##if($replacementTypesMap.get($canonicalName))#*
        *##set($canonicalName=$replacementTypesMap.get($canonicalName))#*
        *##set($name = $ClassUtils.extractClassName($canonicalName))#*
    *##end#*
    *##if($type.packageName.length()>0 && $type.packageName != "java.lang" && $type.packageName != $package && !$trackedImports.get($name))#*
        *#import $canonicalName;
#*      *##set($devNull=$trackedImports.put($name,$canonicalName))#*
    *##end##
#end##
#end##
##
#macro(renderMockedFields $testedClassFields)
#foreach($field in $testedClassFields)
#if(!${field.type.primitive} && !${field.finalType} && !${field.overridden} && !$field.type.array && !$field.type.enum)
    @Mock
    private #resolveTypeName($field.type, {}) $field.name;
#elseif(!$field.type.primitive && !($field.type.canonicalName == "java.lang.String") && $field.finalType && (!$field.static || !$field.final))
    //Field $field.name of type $field.type.name - was not mocked since Mockito doesn't mock a Final class
#elseif($field.type.array && (!$field.static || !$field.final))
    //Field $field.name of type ${field.type.name}[] - was not mocked since Mockito doesn't mock arrays
#elseif($field.type.enum)
    //Field $field.name of type ${field.type.name} - was not mocked since Mockito doesn't mock enums
#end
#end
#end
##
#macro(renderJavaReturnVar $type)
#if($type && $type.name !="void")#resolveTypeName($type, {})#if($type.array)[]#end result = #end
#end
##
#macro(renderJUnitAssert $type)
#if($type && $type.name !="void")        Assert.#renderJunitAssertMethod($type)(#renderJavaCallParams([{"type":$type,"name":"replaceMeWithExpectedResult"}] ,0), result);
#end
#end
##
#macro(renderJunitAssertMethod $type)
#if($type && $type.array)assertArrayEquals#{else}assertEquals#end
#end
##
#macro(renderTestMethods $testedClassMethods $testedClassName)
#foreach($method in $testedClassMethods)
#if($method.isTestable())

    @Test
    public void #renderTestMethodName($method.name)() throws Exception {
        #renderJavaReturnVar($method.returnType)#if($method.static)$testedClassName#{else}$StringUtils.deCapitalizeFirstLetter($testedClassName)#end.${method.name}(#renderJavaCallParams($method.methodParams, 0));
#renderJUnitAssert($method.returnType)
    }
#end
#end
#end
##
#macro(renderTestMethodName $methodName)
test$StringUtils.capitalizeFirstLetter($methodName)#testMethodSuffix($methodName)
#end
##
#macro(testMethodSuffix $methodName)
#if( $trackedTestMethodsCount.get($methodName))
    #set( $suffix= $trackedTestMethodsCount.get($methodName))
#else
    #set( $suffix= 0)
#end
#set( $suffix= $suffix + 1)
#set( $devNull= $trackedTestMethodsCount.put($methodName,$suffix))
#if($suffix!=1)${suffix}#end
#end